init 2 python:
    card_down = "images/misc/down.png"
    card_up   = "images/misc/up.png"
	
	n_cards    = 7
	n_xchanges = 2
	n_cycles   = 3
	
	types  = ["2ch", "ussr", "utan", "uvao"]
	card_dx      = 225
	
	cards_bg = im.Sepia("images/bg/int_dining_hall_day.jpg")
	card_time_koef = 1.0 / 7
	
	VISIBLE = True
	INVISIBLE = False
	
	
	def get_img(img):
		return im.Scale("images/cards/" + img + ".png", card_width, card_height)
	
	
	arrow_width = 50
	
	card_img = {}
	card_img["cover"] = get_img("cover")
	card_img[None] = None
	
	for i in xrange(1, 14):
		for j in types:
			name = str(i) + j
			card_img[(i, j)] = get_img(name)
	
	def generate_cards(dialogs, rival_name, name):
		global game_interuptions, rival, cards_game_name
		global cards_my, cards_rival
		global cycles_left, changes_left
		global cards_state, result_status
		
		game_interuptions = dialogs
		rival = get_rival(rival_name)
		cards_game_name = name
		
		cycles_left = n_cycles
		changes_left = n_xchanges
		cards_state = "init"
		result_status = "in_progress"
		
		cset = []
		while len(cset) < 2 * n_cards:
			name = (random.randint(1, 13), random.choice(types))
			if name not in cset:
				cset.append(name)
		
		cards_rival = []
		for i in xrange(n_cards):
			rival = {}
			rival.visible = False
			rival.name = cset[i]
			rival.interesting = False
			rival.hot = False
			rival.allow = False
			rival.dy = 0
			cards_rival.append(rival)
		
		cards_my = []
		for i in xrange(n_cards):
			my = {}
			my.visible = True
			my.name = cset[n_cards + i]
			my.interesting = False
			my.hot = False
			my.allow = False
			my.dy = 0
			cards_my.append(my)
		
		
		cards_rival[0].name = None
		cards_my[0].name = None
		
		if cards_state == "init":
			deal_card = "sound/sfx/cardgame/new/deal_card_" + str(random.randint(1, 4)) + ".ogg"
			renpy.music.play(deal_card, channel="sound")
	
	def cardflowtime(distance):
		return card_time_koef*distance**0.25
	
	def card_button(card):
		if (card.visible and VISIBLE) or (not card.visible and INVISIBLE) or card.name is None:
			ground = card_img[card.name]
		else:
			ground = card_img["cover"]
		
		if is_image:
			image = im.MatrixColor(ground, im.matrix.saturation(0.1))
			return image
		
		hover = im.MatrixColor(passive, im.matrix.brightness(0.1)*im.matrix.saturation(1.5))
		return ground, hover
	
	def play_choose_sound():
		if cards_state != "me_select_1" and cards_state != "me_select_2":
			renpy.music.play("sound/sfx/cardgame/new/choose_card_2.ogg", channel="sound")


screen cards:
	python:
		card_width   = 210 * get_stage_width()  / 1920
		card_height  = 315 * get_stage_height() / 1080
		
		cards_rival_to_show = []
		cards_my_to_show = []
		
		for i in xrange(n_cards):
			card_rival = cards_rival[i]
			if cards_state == "me_select_2" and card_rival.allow:
				ground, hover = card_button(card_rival, False)
				cards_rival_to_show.append((ground, hover, card_rival.interesting))
			else:
				image = card_button(card_rival, True)
				cards_rival_to_show.append((image, card_rival.interesting))
			
			card_my = cards_my[i]
			if cards_state in ["me_select_1", "me_defend_1", "me_defend_2", "rival_select"] or (cards_state == "me_select_2" and i==my_card) :
				ground, hover = card_button(card_my, False)
				cards_my_to_show.append((ground, hover, card_rival.interesting))
			else:
				image = card_button(card_my, True)
				cards_my_to_show.append((image, card_rival.interesting))
	
	hbox:
		yalign 0.1
		spacing 20
		
		for card_rival in cards_rival_to_show:
			if len(card_rival) == 2:
				image card_rival[0]:
					size (card_width, card_height)
			else:
				vbox:
					spacing 10
					
					button:
						ground card_rival[0]
						hover  card_rival[1]
						size (card_width, card_height)
					if card_rival[-1]:
						image card_up
	hbox:
		yalign 0.9
		spacing 20
		
		for card_my in cards_my_to_show:
			if len(card_my) == 2:
				image card_my[0]:
					size (card_width, card_height)
			else:
				vbox:
					yalign 1.0
					spacing 10
					
					if card_my[-1]:
						image card_down
					button:
						ground card_my[0]
						hover  card_my[1]
						size (card_width, card_height)
	
	if cards_state not in ("interuption", "init"):
		python:
			if      "me" in cards_state:
				card_step = 'Твой'
			elif "rival" in cards_state:
				card_step = 'Чужой'
			else:
				card_step = '---'
			
			if   "defend" in cards_state:
				card_phase = "Защита"
			elif "select" in cards_state:
				card_phase = "Захват"
			elif    "get" in cards_state:
				card_phase = "Вытягивание"
			else:
				card_phase = "Итоги"
			
			if result_status != 'in_progress':
				cards_result = ('Победа', 'Ничья', 'FAIL')[('win', 'draw', 'fail').index(result_status)]
		
		vbox:
			align (0.9, 0.1)
			
			image rival_avatar
			text "Соперник:" size 15
			text cards_game_name size 25
		
		vbox:
			align (0.9, 0.9)
			
			text "Чей ход:" size 15
			text card_step size 25
			
			text "Фаза игры:" size 15
			hbox:
				text
				if cards_state in ["me_defend_1", "me_defend_2"]:
					textbutton "X":
						text_size 25
						action SetVariable('', 'end_of_turn')
		
		ui.button(clicked=None, xanchor=1.0, xpadding=6, xminimum=200, 
				 xpos=card_dx*(n_cards+1)+card_left_dx+button_dx, 
				 ypos=card_bottom_dy+180 - button_dy, 
				 style=style.cards_button, 
			 )
		ui.text("Кругов осталось:", style="button_text", size=15)
		ui.button(clicked=None, xanchor=1.0, xpadding=6, xminimum=200, 
				 xpos=card_dx*(n_cards+1)+card_left_dx+button_dx, 
				 ypos=card_bottom_dy+200 - button_dy, 
				 style=style.cards_button, 
			 )
		ui.text(str(cycles_left), style="button_text", size=25)
		
		ui.button(clicked=None, xanchor=1.0, xpadding=6, xminimum=200, 
				 xpos=card_dx*(n_cards+1)+card_left_dx+button_dx, 
				 ypos=card_bottom_dy+270 - button_dy, 
				 style=style.cards_button, 
			 )
		ui.text("Обменов осталось:", style="button_text", size=15)
		ui.button(clicked=None, xanchor=1.0, xpadding=6, xminimum=200, 
				 xpos=card_dx*(n_cards+1)+card_left_dx+button_dx, 
				 ypos=card_bottom_dy+290 - button_dy, 
				 style=style.cards_button, 
			 )
		if changes_left == 0:
			changes_left_text = "---"
		else:
			changes_left_text = str(changes_left)
		ui.text(changes_left_text, style="button_text", size=25)
		
		if result_status != 'in_progress':
			textbutton cards_result:
				text_size 72
				action None


init python:
	def move_buttons(setk, k, setj, j):
		for i in xrange(n_cards):
			cards_my[i].hot = False
			cards_rival[i].hot = False
		setk[k].hot = True
		setj[j].hot = True
		
		setk[k], setj[j] = setj[j], setk[k]
	
	def cards_interact():
		if cards_state == "me_defend_1":
			renpy.music.play("sound/sfx/cardgame/new/choose_card_2.ogg", channel="sound")
		elif cards_state == "me_defend_2":
			renpy.music.play("sound/sfx/cardgame/new/choose_card_1.ogg", channel="sound")
	
	def xchange_cards():
		for i in xrange(n_cards):
			cards_my[i].interesting = False
			cards_rival[i].interesting = False
		cards_my[my_card].visible = False
		cards_rival[rival_card].visible = True
		move_buttons(cards_my, my_card, cards_rival, rival_card)
		
		take_card = "sound/sfx/cardgame/new/take_card_" + random.randint(1, 3) + ".ogg"
		renpy.music.play(take_card, channel="sound")
	
	def card_value(x):
		if x.name[0] == 1:
			return 14
		return x.name[0]
	
	def sort_cards():
		cards_rival.sort(cmp, card_value)
		cards_my.sort(cmp, card_value)
	
	def interuption_region():
		if cards_state == "me_select_1":
			renpy.music.play("sound/sfx/cardgame/new/choose_card_2.ogg", channel="sound")
		elif cards_state == "rival_defend":
			renpy.music.play("sound/sfx/cardgame/new/choose_card_1.ogg", channel="sound")
		
		position = (cycles_left, cards_state, "call")
		if position in game_interuptions:
			renpy.call(game_interuptions[position])
			del game_interuptions[position]
		position = (cycles_left, cards_state, "jump")
		if position in game_interuptions:
			cards_state = "interuption"
			renpy.jump(game_interuptions[position])
	
	def what_category(cardset):
		ans = []
		summ = 0
		for i in xrange(n_cards):
			cardset[i].interesting = False
		for length in [4, 3, 2]:
			for i in xrange(n_cards-length+1):
				if cardset[i].interesting:
					continue
				val = card_value(cardset[i])
				for j in xrange(i+1, i+length):
					if card_value(cardset[j]) != val:
						break
				else:
					for j in xrange(i, i+length):
						cardset[j].interesting = True
					ans.append([length, val])
					summ += length
		if ans:
			return summ, ans
		
		cardset[n_cards-1].interesting = True
		return 1, [[1, card_value(cardset[n_cards-1])]]
	
	def cmpset(a, b):
		if b[0] != a[0]:
			return b[0] - a[0]
		return b[1] - a[1]
	
	def compare_sets(result_my, gr_my, result_rival, gr_rival):
		if result_my > result_rival:
			return 'win'
		if result_my < result_rival:
			return 'fail'
		
		if len(gr_my) < len(gr_rival):
			return 'win'
		if len(gr_my) > len(gr_rival):
			return 'fail'
		
		for i in xrange(len(gr_my)):
			if gr_my[i][0] > gr_rival[i][0]:
				return 'win'
			if gr_my[i][0] < gr_rival[i][0]:
				return 'fail'
			
			if gr_my[i][1] > gr_rival[i][1]:
				return 'win'
			if gr_my[i][1] < gr_rival[i][1]:
				return 'fail'
		
		return 'draw'
	
	def count_score():
		result_my, gr_my = what_category(cards_my)
		result_rival, gr_rival = what_category(cards_rival)
		
		gr_my.sort(cmpset)
		gr_rival.sort(cmpset)
		
		return compare_sets(result_my, gr_my, result_rival, gr_rival)

label cards_gameloop:
	while True:
		pause 0.01
		
		python:
			if cards_state == "init":
				new_state = "rival_select"
			
			elif cards_state == "rival_select":
				interuption_region()
				my_card = rival.pick_my_card()
				for i in xrange(n_cards):
					cards_my[i].interesting = False
					cards_rival[i].interesting = False					 
				cards_my[my_card].interesting = True
				
				if rival.allow_to_defend():
					new_state = "me_defend_1"
				else:
					new_state = "rival_get"
			
			elif cards_state == "me_defend_1":
				interuption_region()
				answer = cards_interact()
				if answer == "end_of_turn":
					new_state = "rival_get"
				else:
					type, index = answer
					cards_my[index].dy = -40
					prev_answer = index
					new_state = "me_defend_2"
			
			elif cards_state == "me_defend_2":
				interuption_region()
				answer = cards_interact()
				cards_my[prev_answer].dy = 0
				if answer == "end_of_turn":
					new_state = "rival_get"
				else:
					type, index = answer
					if prev_answer == index:
						cards_my[prev_answer].dy = 0
						new_state = "me_defend_1"
					else:
						move_buttons(cards_my, prev_answer, cards_my, index)
						changes_left -= 1
						if changes_left == 0:
							new_state = "rival_get"
						else:
							new_state = "rival_select"
			
			elif cards_state == "rival_get":
				if changes_left == 0:
					my_card = rival.pick_my_card_last()
				for i in xrange(n_cards):
					cards_my[i].interesting = False
					cards_rival[i].interesting = False
				cards_my[my_card].interesting = True
				
				interuption_region()
				
				for i in xrange(n_cards):
					if cards_rival[i].name is None:
						rival_card = i
				xchange_cards()
				changes_left = n_xchanges
				rival.allow_to_take()
				new_state = "me_select_1"
			
			elif cards_state == "me_select_1":
				interuption_region()
				for i in xrange(n_cards):
					if cards_my[i].name is None:
						my_card = i
				new_state = "me_select_2"
			
			elif cards_state == "me_select_2":
				interuption_region()
				answer = cards_interact()
				type, index = answer
				if type == "my":
					cards_my[index].dy = 0
					new_state = "me_select_1"
				else:
					rival_card = index
					for i in xrange(n_cards):
						cards_rival[i].interesting = False
						cards_my[i].interesting = False
					cards_rival[index].interesting = True
					new_state = "rival_defend"
			
			elif cards_state == "rival_defend":
				interuption_region()
				if changes_left == 0:
					new_state = "me_get"
				else:
					if not rival.want_to_defend():
						changes_left == 0
						new_state = "me_get"
					else:
						changes_left -= 1
						i, j=rival.what_to_xchange()
						move_buttons(cards_rival, i, cards_rival, j)
						tmp_interest = cards_rival[i].interesting
						cards_rival[i].interesting = cards_rival[j].interesting
						cards_rival[j].interesting = tmp_interest
						new_state = "me_select_2"
			
			elif cards_state == "me_get":
				interuption_region()
				cards_my[my_card].dy = 0
				xchange_cards()
				cycles_left -= 1
				if cycles_left != 0:
					changes_left = n_xchanges
					new_state = "rival_select"
				else:
					new_state = "results"
			
			elif cards_state == "results":
				interuption_region()
				sort_cards()
				for i in xrange(n_cards):
					cards_rival[i].visible = True
					cards_my[i].visible = True
				new_state = count_score()
			
			cards_state = new_state

